package main

goimport (
    "strings"
)

const a : int64 = 0

export const isExported := true
const NotExported := true

String ~ utf8
export notExported ~ uint64
export ExportedString ~ String

main : proc(ctx: context) = {
    str := @go.strings.ToUpper("str")

    b : float32 = 0.0

    language := "cog" // utf8
    lang : utf8 = "cog"
    lng : ascii = "cog"

    leeng := lng
    c1 := `hello
    
        world`
    c2 := "hello\n\n\tworld"

    @print(c1)
    @print(c2)

    language = "go"

    if true {
        break
    } else {
        lng = "else"
    }

    if true != false {}
    if true == false && true != false {}
    if (language == "cog") != (lng == "cog") {}
    if 5 <= 6 {}
    if !true {}

    fl := -0.6e-7

    collection : set[string] = { "hello1", "hello2" }

    maths := 5 * 6 / (2 + 3)

ifLabel:
    if true {
        if true {
            break ifLabel
        }
    }

    newString := definedHere

    newLang := @if(language == "cog", 25 + 10 - 6, 5)

    earth : planet = {
        radius = 10,
        mass = 20,
    }

    _ = earth.radius

caseSwitch:
    switch {
    case 5e-6 <= 6:
        break
    case 5 >= 0.6:
        break caseSwitch
    default:
        lang = "foo"
    }

    switch language {
    case "en":
    case "nl":
    default:
    }

    enum1 := Status.Open
    enum2 := Status.Closed

    if enum1 == enum2 {
        @print(enum1)
    }

    tuple : Tuple = {"hello", 10, false}

    either : Either = "hello"

    utf : utf8?  = "hello"
    // option : Option? // not allowed
    utf = "option"
    
    if utf? {
        @print("hello")
    }
    
    option : uint64?
    
    if option? {
        @print("do not print")
    }

    option = 10

    if option? {
        @print("do print")
    }

    upperCaseString := upper(language)
    @print(upperCaseString)

    @print(upper("foo", "bar"))

    // _ = Planets.Earth.mass
}

const definedHere := "defined globally!"

planet ~ struct {
    name : ascii

    export pressure : float64

    export (
        radius : float64
        mass : float64
    )
}

Status ~ enum[utf8] {
    Open := "open",
    Closed := "closed",
}

Planets ~ enum[planet] {
    Earth := {
        radius = 0.5,
        mass = 0.1,
    },
}

Tuple ~ utf8 & uint64 & bool

Either ~ utf8 | uint64

Option ~ utf8?

upper : func(str : utf8, optional? : utf8, alsoOptional? : utf8 = "wassup") utf8 = {
    return @go.strings.ToUpper(str) + optional + alsoOptional
}

/*

// string can be either ascii or utf8.
// this is determined at compile time.
// argument type determines return type as well.
export upper : func[S string](str : S) S = {
    switch type str {
    case ascii:
        return @go.strings.Upper(@cast[utf8](str))
    case utf8:
        return @go.strings.Upper(str)
    }
}

async {

}

handleRequest : proc(ctx: context, req: Request) (res: Response, err: error) {
    return error.none
}

// if-expression builtin function (called with @if)
// else is an optional argument denoted with :?
// if an optional argument is ommited, it will have the zero value of the type
if : func[T any](expr: bool, thenExpr: T, elseExpr:? T) T = {
    if expr {
        return thenExpr
    } else {
        return elseExpr
    }
}
*/
