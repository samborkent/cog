package main

goimport (
    "strings"
)

const a : int64 = 0

export const isExported := true
const NotExported := true

String ~ utf8
export notExported ~ uint64
export ExportedString ~ String

main : proc(ctx: context) = {
    str := @go.strings.ToUpper("str")

    b : float32 = 0.0

    language := "cog" // utf8 (or detect based on characters in str)
    lang : utf8 = "cog"
    lng : ascii = "cog"

    leeng := lng
    c1 := `hello
    
        world`
    c2 := "hello\n\n\tworld"

    @print(c1)
    @print(c2)

    language = "go"

    if (true) {
        break
    } else {
        lng = "else"
    }

    if (true != false) {}
    if (true == false and true != false) {}
    if (language == "cog" xor lng == "cog") {}
    if (5 <= 6) {}
    if (!true) {}

    fl := -0.6e-7

    collection : set[string] = { "hello1", "hello2" }

    maths := 5 * 6 / (2 + 3)

ifLabel:
    if (true) {
        if (true) {
            break ifLabel
        }
    }

    newString := definedHere

    newLang := @if(language == "cog", 25 + 10 - 6, 5)

    earth : planet = {
        radius = 10,
        mass = 20,
    }

    _ = earth.radius

caseSwitch:
    switch {
    case 5e-6 <= 6:
        break
    case 5 >= 0.6:
        break caseSwitch
    default:
        lang = "foo"
    }

    switch language {
    case "en":
    case "nl":
    default:
    }

    enum1 := Status.Open
    enum2 := Status.Closed

    if (enum1 == enum2) {
        @print(enum1)
    }

    tuple : Tuple = {"hello", 10, false}

    // _ = Planets.Earth.mass

    either : Either = "hello"
}

const definedHere := "defined globally!"

planet ~ struct {
    name : ascii

    export pressure : float64

    export (
        radius : float64
        mass : float64
    )
}

Status ~ enum[utf8] {
    Open := "open",
    Closed := "closed",
}

Planets ~ enum[planet] {
    Earth := {
        radius = 0.5,
        mass = 0.1,
    },
}

Tuple ~ utf8, uint64, bool

Either ~ utf8 | uint64

/*
{
    L := upper(language)
}

// string can be either ascii or utf8.
// this is determined at compile time.
// argument type determines return type as well.
export upper : func(str: string) string = {
    return @go.strings.Upper(str) // TODO: find valid way to convert str to Go string
}
    async {

    }
}

handleRequest : proc(ctx: context, req: Request) (res: Response, err: error) {
    return error.none
}

// if-expression builtin function (called with @if)
// else is an optional argument denoted with :?
// if an optional argument is ommited, it will have the zero value of the type
if : func[T any](expr: bool, thenExpr: T, elseExpr:? T) T = {
    if expr {
        return thenExpr
    } else {
        return elseExpr
    }
}
*/
